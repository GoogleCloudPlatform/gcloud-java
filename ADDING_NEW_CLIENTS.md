## How to Add a New Client Library

### Overview

This document outlines how to add a new client library to `gcloud-java`.  New client libraries should be submodules located in a folder within the main repository, built using Maven.  A client library should contain the following items:

* An API layer, with which users will interact.  This includes model objects and a service class. 
* An SPI layer, which translates gcloud-java API calls into RPCs using an autogenerated client library.  In almost all use cases, the user will not directly interact with this code.  Separating this code from the API layer allows the API layer to remain stable despite changes to the autogenerated libraries used.
* A test helper class, which allows users to easily interact with a local emulator (if possible).  If there is no emulator available and the service is too complex to create a mock, then this helper should facilitate separation of test data from other user data and enable easy cleanup.
* Tests, including unit tests and integration tests.
* A command line example application.
* Documentation, which is comprised of READMEs, Javadoc, and code snippets.

### Components of a new client library

#### API layer

Before starting work on the API layer, write a design document and provide sample API code, either in the design document or as a pull request tagged with the "don't merge" label.  As part of the design process, be sure to examine the Google Cloud service API and any implementations provided in other gcloud-* language libraries.  Solicit feedback from other contributors to the repository.

When possible, make classes immutable, providing builders when necessary.  Commonly-used classes that contain metadata should also contain a subclass that provides functions on that metadata.  For example, see `BlobInfo` (the metadata class) and `Blob` (the functional class).  The builders for both objects should implement a common interface or abstract class, and the subclass should delegate to the metadata class builder.  Make model object classes serializable.  Also, make classes final when possible, except when the class contains functionality that cannot be fully tested by users without mocking the object.

Notes/reminders:
* API layer classes should be located in the package `com.google.cloud.servicename`, where "servicename" corresponds to the name of the Cloud service.
* Override the `ServiceOptions.defaultRetryParams()` method in your service's options class to align with the Service Level Agreement (SLA) given by the underlying service.  See #857 and #860 for context.
* See conventions about overriding the `equals` and `hashCode` methods in the discussion of #892.
* While not all fields for model objects need to be exposed to the user, `gcloud-java` clients should get and set all relevant fields when making RPC calls to the Cloud service's API.  For example, since the `parent` field of Cloud Resource Manager Project objects is in alpha (at the time this is written) and not available to most users, `gcloud-java-resourcemanager` gets and sets the parent when interacting with the Cloud Resource Manager, but does not expose the parent to users. This avoids the user inadvertently attempting to unset the parent when updating a project.
* Be aware of differences in "update" behavior and name update/replace methods accordingly in your API.  See #321 for context.

#### SPI layer

The SPI layer classes should be located in the package `com.google.cloud.servicename.spi`.  In most cases, the SPI layer should contain at least three classes:
* An RPC factory interface (allows for the implementation to be loaded via the `java.util.ServiceLoader`).
* An RPC interface that contains all RPC methods.
* A default RPC implementation.

#### Test helpers

Test helper classes should be located in the package `com.google.cloud.servicename.testing`.  The naming convention for test helpers is `[Local|Remote][Service]Helper.java`.  For example, the local test helper for `gcloud-java-datastore` is named `LocalDatastoreHelper` and the remote test helper for `gcloud-java-storage` is named `RemoteStorageHelper`.  All test helpers should contain public `create` and `options` methods, and local helpers should contain `start` and `stop` methods.  See existing test helpers for information on what each of those methods should do.

There are three types of test helpers:
* When a local emulator is already available, your test helper should launch that emulator and return service options to connect to that local emulator.  This enables both users and our own library to run unit tests easily.  An example of this type of helper is `LocalDatastoreHelper`.  Google Cloud Datastore provides a script that launches a local datastore, so `LocalDatastoreHelper` launches that script in a separate process when the user calls `start()`.

* When there is no local emulator but the service is simple enough to write an emulator, you should do so.  The emulator should listen to a port for requests, process those requests, and send responses back, being as true to the actual service as possible.  Be sure to document differences between your emulator and the actual service.  Examples of this type of test helper are `LocalResourceManagerHelper` and `LocalDnsHelper`.

* When there is no local emulator and the service is too complex to write a solid emulator, the test helper should contain methods to get options and separate test data from other user data.  `RemoteStorageHelper` is an example of this type of test helper, since there is no local emulator for Google Cloud Storage (at the time that this is written) and because the Google Cloud Storage API is complex.  `RemoteStorageHelper` has methods to:
  * Get service options settings.
  * Create a test bucket with a sufficiently obscure name (to separate the bucket from any of the users other data).
  * Clear up data left over from tests in that test bucket.


#### Tests

API-level functionality should be well-covered by unit tests.  Coders and reviewers should examine test coverage to ensure that important code paths are not being left untested.  As of now, `gcloud-java` relies on integration tests to test the SPI layer.  Unit tests for the API layer should be located in the package `com.google.cloud.servicename`.  Integration tests should be placed in a separate package, `com.google.cloud.servicename.it`, which enables us to catch method access bugs.  Unit tests for the test helper should be placed in the package `com.google.cloud.servicename.testing`.

Simple service-related tests should be added to [GoogleCloudPlatform/gcloud-java-examples](https://github.com/GoogleCloudPlatform/gcloud-java-examples/tree/master/test-apps).  To test releases and platform-specific bugs, it's valuable to deploy the apps in that repository on App Engine, Compute Engine, and from your own desktop.

#### Example application

The example application should be a simple command line interface for the service.  It should use common library use patterns so that users see good examples of how to use `gcloud-java` when viewing the source code.  Be sure to keep the examples up to date if/when there are updates that make the API cleaner and more concise.  See examples of applications under the `gcloud-java-examples` folder.  The example application should be in the package `com.google.cloud.examples.servicename`.

#### Documentation

* Include a summary of the service and code snippets on the main repository's README.  These snippets should be simple and cover a few common usage patterns.  The README snippets should also be added to `gcloud-java-examples` in the package `com.google.cloud.examples.servicename.snippets`.  Placing snippet code in the repository ensures that the snippet code builds when Travis CI is run.  For this purpose, README snippets and the snippet code in `gcloud-java-examples` should be kept in sync.  As of yet, we do not have unit tests for snippets, so the snippets should be tested periodically, especially after any relevant library updates.
* Create a README in the client library's folder.  This README should mimic the structure of other client libraries' READMEs.  In particular, you should create a step-by-step "Getting Started" guide.  See [`gcloud-java-datastore`'s README](https://github.com/GoogleCloudPlatform/gcloud-java/blob/master/gcloud-java-datastore/README.md) for reference.  All code in that step-by-step guide should also be included in the `gcloud-java-examples` snippets package.
* The API and test helper packages should have `package-info.java` files.  These files should contain descriptions of the packages as well as simple example code and/or links to code snippets.
* Public methods, classes, and builders should contain meaningful Javadoc.  Document both unchecked and checked exceptions.
* Update [`TESTING`](https://github.com/GoogleCloudPlatform/gcloud-java/blob/master/TESTING.md) with how to run tests using the test helper.
* Update the [`gcloud-java-examples` README](https://github.com/GoogleCloudPlatform/gcloud-java/blob/master/gcloud-java-examples/README.md) with instructions on how to run your example application.

Notes/reminders:
* Clearly document which APIs must be enabled in the Developers Console's API Manager.
* Versioning in documentation is automatically updated by the script `utilities/update_docs_version.sh`.  Be sure to examine that script to make sure any version-dependent documentation will be updated properly upon release.

### Workflow

New services should be created in a branch based on `master`.  The branch name should include "alpha".  For example, while developing `gcloud-java-pubsub`, all Pub/Sub related work should be done in `pubsub-alpha`.  All code should be submitted through pull requests from a branch on a forked repository.  Limiting pull request size is very helpful for reviewers.  All code that is merged into the branch should be standalone and well-tested.  Any todo comments in the code should have an associated Github issue number for tracking purposes.  You should periodically pull updates from the master branch, especially if there are project-wide updates or if relevant changes have been made to the core utilities library, `gcloud-java-core`.

Create at least two milestones (stable and future) for your service and an issue tag with the service name.  Create issues for any to-do items and tag them appropriately.  This keeps an up-to-date short-term to-do list and also allows for longer term roadmaps.

Be sure you've configured the base folder's `pom.xml` correctly.
  * Add your module to the base directory's `pom.xml` file under the list of modules.
  * Add your module to the javadoc packaging settings.  See PR #802 for an example.
  * Add your example to the assembler plugin.  PR #839 includes examples of using appassembler.

When your client library is complete, contact the service owners to get a review.  The primary purpose of this review is to make sure that the gcloud-java client interacts with the Cloud service properly.  Present the reviewers with a link to the Github repository, as well as your (updated) design document that details the API.

### Closing remarks

* Efforts should be made to maintain the current style of the repository and a consistent style between gcloud-java client libraries.
  * We anticipate that people will often use multiple `gcloud-java` clients, so we don't want differences in conventions from library to library.  Look at existing `gcloud-java` clients to see coding and naming conventions.
  * Codacy is configured to report on pull requests about style issues.  Whenever possible, those comments should be addressed.  Coders and reviewers should also run a linter on pull requests, because the Codacy tool may not catch all style errors.
* When weighing which client libraries to add, consider that a hand-crafted `gcloud-java` client library is especially useful if it can abstract away and/or make java-idiomatic significant parts of a service's autogenerated API.

